ptm <- proc.time()
for (p in 1:(iter_num+1))
{
xx= train[,1:2]
y= train[,3]
fit=mlegp(xx,y)
if (is.na(fit["sig2"])) {
errors[p] = errors[p-1]
select_index = screen_index(fit,train,pool,add,"Random") #
} else {
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
}
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 20
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
for (p in 1:(iter_num+1))
{
xx= train[,1:2]
y= train[,3]
fit=mlegp(xx,y)
if (is.na(fit["sig2"])) {
errors[p] = errors[p-1]
select_index = screen_index(fit,train,pool,add,"Random") #sometimes the return model can be used log likelihood = -Nan
} else {
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
}
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
to_remove = if (noise_level>0) add*2 else add
setwd("~/OED_all/OED_multiple_surface/src/Three_in_One")
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 14
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
for (p in 1:(iter_num+1))
{
fit=mlegp(train[,1:2],train[,3])
while (is.na(fit["sig2"])) {
to_remove = if (noise_level>0) add*2 else add
train = train[1:(nrow(train)-to_remove),]
fit=mlegp(train[,1:2],train[,3])
}
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
dim(train)
remove
to_remove
add
iter_num
14*3
15*3
fit=mlegp(train[,1:2],train[,3])
(is.na(fit["sig2"]))
to_remove = if (noise_level>0) add*2 else add
train = train[1:(nrow(train)-to_remove),]
fit=mlegp(train[,1:2],train[,3])
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
fit=mlegp(train[,1:2],train[,3])
while (is.na(fit["sig2"])) {
to_remove = if (noise_level>0) add*2 else add
train = train[1:(nrow(train)-to_remove),]
fit=mlegp(train[,1:2],train[,3])
}
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 20
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
for (p in 1:(iter_num+1))
{
fit=mlegp(train[,1:2],train[,3])
while (is.na(fit["sig2"])) {
to_remove = if (noise_level>0) add*2 else add
train = train[1:(nrow(train)-to_remove),]
fit=mlegp(train[,1:2],train[,3])
}
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
dim(train)
length(errors)
21*3
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 20
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
for (p in 1:(iter_num+1))
{
fit=mlegp(train[,1:2],train[,3])
while (is.na(fit["sig2"])) {
to_remove = if (noise_level>0) add*2 else add
train = train[1:(nrow(train)-to_remove),]
fit=mlegp(train[,1:2],train[,3])
p = p- 1
}
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
dim(train)
length(errors)
plot(errors)
setwd("~/OED_all/OED_multiple_surface/src/Three_in_One")
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 14
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R","train_GP.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
p=1
model_tr = train_GP(train)
fit = model_tr$fit
train = model_tr$train
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
fit
train_GP(train)
model_tr = train_GP(train)
fit = model_tr$model
fit2
fit
setwd("~/OED_all/OED_multiple_surface/src/Three_in_One")
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 14
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 14
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R","train_GP.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
model_tr = train_GP(train)
fit = model_tr$model
train = model_tr$train
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "EN"
add = 3
iter_num = 16
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
file_path = file.path(data_path,paste(set_name,".csv",sep=""))
Rcodes = c("prepare_train.R","compute_kernel.R","predict_benchmark.R",
"update_train_pool.R","save_res.R","screen_index.R","train_GP.R")
for (Rcode in Rcodes) {
source(file.path(helper_path,Rcode))
}
data = prepare_train(file_path,random_seed,start_size,noise_level)
train = data$train
pool = data$pool
pool_all = data$pool_all
benchmark = data$benchmark
errors = as.numeric()
ptm <- proc.time()
for (p in 1:(iter_num+1))
{
model_tr = train_GP(train)
fit = model_tr$model
train = model_tr$train
errors[p] =  predict_benchmark(fit,train,benchmark,unfold=FALSE)
select_index = screen_index(fit,train,pool,add,method)# This part is different for different OED method
res = update_train_pool(select_index,train,pool,pool_all,noise_level)
train = res$train
pool = res$pool
pool_all = res$pool_all
}
save_res(out_data_path,set_name,noise_level,random_seed,add,iter_num,errors,train,method)
#
plot(errors)
setwd("~/OED_all/OED_multiple_surface/src/Sanity")
source("../setpath.R")
library(mlegp)
set_name = 3
start_size = 450
data_all = read.csv(file.path(data_path,paste(set_name,".csv",sep="")), header=TRUE)
data_all = as.matrix(data_all[sample(nrow(data_all)),])
std = noise_level*0.01
train = data_all[1:start_size,]
#train = rbind(train,train,train)
#train[,3] = train[,3] + rnorm(nrow(train),sd=0.09)
data = data_all[(start_size+1):(start_size+3000),]
xx=as.matrix(train[,1:2])
y=as.matrix(train[,3])
fit=mlegp(xx,y)
source("../setpath.R")
source(file.path(helper_path,"predict_benchmark.R"))
source(file.path(helper_path,"compute_kernel.R"))
source("../setpath.R")
source(file.path(helper_path,"predict_benchmark.R"))
source(file.path(helper_path,"compute_kernel.R"))
library(mlegp)
set_name = 3
start_size = 50
data_all = read.csv(file.path(data_path,paste(set_name,".csv",sep="")), header=TRUE)
data_all = as.matrix(data_all[sample(nrow(data_all)),])
std = noise_level*0.01
train = data_all[1:start_size,]
data = data_all[(start_size+1):(start_size+3000),]
xx=as.matrix(train[,1:2])
y=as.matrix(train[,3])
fit=mlegp(xx,y)
inverse=fit$invVarMatrix
d=fit[["numDim"]]
beta=fit[["beta"]]
sigma=fit[["sig2"]]
mu=fit[["mu"]]
nugget=fit[["nugget"]]
number=fit[["numObs"]]
fitZ = fit$Z
df=as.matrix(train)
covariance = compute_kernel(d,beta,sigma, train,train)
invers = chol2inv(chol(covariance))
inverse = chol2inv(chol(covariance))
res = predict_benchmark(inverse,d,beta,sigma, mu, nugget, nubmer,fitZ,df,data,unfold=TRUE)
setwd("~/OED_all/OED_multiple_surface/src/Sanity")
source("../setpath.R")
source(file.path(helper_path,"predict_benchmark.R"))
source(file.path(helper_path,"compute_kernel.R"))
library(mlegp)
set_name = 3
start_size = 50
data_all = read.csv(file.path(data_path,paste(set_name,".csv",sep="")), header=TRUE)
data_all = as.matrix(data_all[sample(nrow(data_all)),])
std = noise_level*0.01
train = data_all[1:start_size,]
benchmark = data_all[(start_size+1):(start_size+3000),]
xx=as.matrix(train[,1:2])
y=as.matrix(train[,3])
fit=mlegp(xx,y)
inverse=fit$invVarMatrix
d=fit[["numDim"]]
beta=fit[["beta"]]
sigma=fit[["sig2"]]
mu=fit[["mu"]]
nugget=fit[["nugget"]]
number=fit[["numObs"]]
fitZ = fit$Z
df=as.matrix(train)
covariance = compute_kernel(d,beta,sigma, train,train)
inverse = chol2inv(chol(covariance))
newcov = compute_kernel(d,beta,sigma, train,benchmark)
diag(newcov)=diag(newcov) #+nugget
var=diag(sigma+nugget-newcov%*%inverse%*%t(newcov))
real=benchmark[,3]
# This is the predicted mean and variance by the interface coming with the package
pred = predict(fit, data[,1:2], se.fit=TRUE)
mean_pred = pred$fit
var_pred = (pred$se.fit)^2
# This is the predicted mean and variance by the interface coming with the package
pred = predict(fit, benchmark[,1:2], se.fit=TRUE)
mean_pred = pred$fit
var_pred = (pred$se.fit)^2
plot(var,var_pred)
sigma + nugget
covariance = compute_kernel(d,beta,sigma, train,train)
diag(covariance)=diag(covariance ) +  sigma + nugget
inverse = chol2inv(chol(covariance))
newcov = compute_kernel(d,beta,sigma, train,benchmark)
diag(newcov)=diag(newcov) #+nugget
var=diag(sigma+nugget-newcov%*%inverse%*%t(newcov))
plot(var,var_pred)
setwd("~/OED_all/OED_multiple_surface/src/Three_in_One")
source("../setpath.R")
library(mlegp)
# args = commandArgs(TRUE)
# add = as.integer(args[1])
# iter_num = as.integer(args[2])
# pool_size = as.integer(args[3])
# start_size = as.integer(args[4])
#
# random_seed = as.integer(args[5])
# set_name = args[6]
# noise_level = as.integer(args[7])
method = "MI"
add = 3
iter_num = 2
pool_size = 500
start_size = 50
random_seed= 1
set_name = 1
noise_level = 0
